import * as functions from "firebase-functions";
import * as firebase from "firebase-admin";
import * as tf from "@tensorflow/tfjs";
import {DocumentSnapshot} from "firebase-functions/lib/providers/firestore";
import {Compound} from "./compound";
import {join} from "path";
import {Bucket} from "@google-cloud/storage";

const util_1 = require("util");
require("util.promisify").shim();
import "tfjs-node-save";
import {NodeFileSystem} from "tfjs-node-save/io/file_system";
import {Rank, Tensor} from "@tensorflow/tfjs-core";

// The Firebase Admin SDK to access the Firestore Database.
firebase.initializeApp();

// Defining where model files should be stored in the Node.js filesystem:
const tmpdir = require("os").tmpdir();
const fs = require("fs");
const modelPath = join(tmpdir, "tfjs-model");

/**
 * Helper function to transform an object containing image data to a "real" 2-dimensional array matrix.
 * This is basically a workaround since storing multi-dimensional arrays in Firestore is currently not possible.
 */
const transformImageData = function (imageData: object[]): number[][] {
    const matrix: number[][] = [];
    imageData.forEach((row) => {
        const matrixRow: number[] = [];
        for (const key in row) {
            if (row.hasOwnProperty(key)) {
                matrixRow.push(row[key]);
            }
        }
        matrix.push(matrixRow);
    });
    return matrix;
};

/**
 * Downloads all pre-processed image matrices along with their labels from Firestore.
 *
 * Returns a Compound object storing images and label values.
 */
const getTrainingImages = async function(): Promise<Compound> {
    const images: number[][][] = [];
    const labels: number[] = [];

    const querySnapshot: firebase.firestore.QuerySnapshot = await firebase.firestore().collection("training")
        .select("image", "itemLabel")
        .get();
    querySnapshot.forEach((doc: DocumentSnapshot) => {
        const matrix = transformImageData(doc.data().image);
        images.push(matrix);
        labels.push(doc.data().itemLabel);
    });
    return new Compound(images, labels);
};

/**
 * Uploads temporarily stored model files in the Node.js filesystem generated by TensorFlow.js to Firebase Storage.
 */
const uploadModelFiles = async function(): Promise<boolean> {

    const bucket: Bucket = firebase.storage().bucket(firebase.app().options.storageBucket);

    const tempJSONPath = join(modelPath, "model.json");
    const tempBINPath = join(modelPath, "weights.bin");

    await bucket.upload(tempJSONPath);
    console.log("Uploaded", tempJSONPath);
    await bucket.upload(tempBINPath);
    console.log("Uploaded", tempBINPath);

    fs.unlinkSync(tempJSONPath);
    fs.unlinkSync(tempBINPath);

    return true;
};

// Training with TensorFlow.js required a lot of resources. Increasing memory here:
const runtimeOpts = {
    timeoutSeconds: 540,
    memory: "2GB"
};

// @ts-ignore
export const tensorflow = functions.runWith(runtimeOpts).https.onRequest(async (request, response) => {
    // First, get the training images from Firestore:
    const data: Compound = await getTrainingImages();

    console.log("images shape = [" + data.images.length + ", " + data.images[0].length + ", " + data.images[0][0].length + "]");

    // Defining the model:
    const model = tf.sequential();
    model.add(tf.layers.flatten({inputShape: [28, 28]}));
    model.add(tf.layers.dense({units: 128, activation: "relu"}));
    model.add(tf.layers.dense({units: 10, activation: "softmax"}));

    // Preparing the model for training: Specify the loss and the optimizer.
    model.compile(
        {
            optimizer: "adam",
            loss: "sparseCategoricalCrossentropy",
            metrics: ["accuracy"]
        }
    );

    // @ts-ignore
    const trainImages: Tensor<Rank> = tf.tensor3d(data.images, [data.images.length, 28, 28]);
    // @ts-ignore
    const trainLabels: Tensor<Rank>  = tf.tensor1d(data.labels);

    try {
        await model.fit(trainImages, trainLabels, {epochs: 5}).then(async () => {
            console.log("Done training");

            // Saving to file system (in this case files are saved in the local Node.js filesystem inside Firebase Functions):
            const saveResult = await model.save(new NodeFileSystem(modelPath));
            console.log("saveResult = ", saveResult);

            // Training is done. Now the locally stored model files are uploaded to Firebase Storage:
            await uploadModelFiles();
        });
        response.send("Success! Trained the model.");
    } catch (e) {
        console.error("An error occurred training the model", e);
        response.send("Error. Check the logs.");
    }
});

